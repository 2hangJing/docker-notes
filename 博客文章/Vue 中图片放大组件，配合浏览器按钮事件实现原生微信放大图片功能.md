微信公众号开发中遇到图片放大需求，要求可手动放大缩小，并且可支持 PC、移动端浏览器正常使用。之前需求是图片自适应最大放大即可，现在产品、设计反应某些字体、图片太小简单的屏幕自适应无法满足故而修改为可手动放大缩小的功能。单说图片放大缩并且支持PC、移动浏览器是没有问题的，直接使用的 PhotoSwipe 插件满足要求，但是在微信端、移动端在放大图片时容易点击返回按钮，因为是单页面应用从而返回上一页导致误操作问题。

## 一、问题展示

单页面应用不可避免的遇到浏览器返回按钮导致的实际操作逻辑与设计、理想中的不同，这次的问题如下GIF 所示：

![](https://www.ismoon.cn/static/4e0ab5cb726c4d2d076736a321c72187.gif)

可以看到逻辑流程应该是：**列表页--> 详情页 --> 图片放大 -->点击浏览器返回按钮 -->关闭图片放大，显示详情页**

此单页面是由 `Vue2.x` 开发，由于 `vue-router` 对 `url` 的监听当用户在公众号中习惯性的点击返回按钮想关闭放大的图片时导致 `url` 改变从而触发 DOM 重绘为其他 `url` 对应页面。

## 二、解决方案

既然问题的原因已经知晓那么解决问题的方法也就不甚明了了，目前项目中有俩种解决办方法：

1.  **点击图片后跳转一个专门用来放大图片的页面，从而避免点击返回按钮之后出现页面流程逻辑问题**
2.  **点击图片时弹出图片放大图层在浏览器页面历史栈中添加一个当前 `url` 历史，当点击返回按钮后关闭放大图层， `url` 因为未变化 `vue-router` 不会触发页面DOM 更新，从而避免击返回按钮之后出现页面流程逻辑问题**

俩种办法第一种容易，第二种复杂，但是第一种有一个致命的缺陷：

放大图片中需要跳转页面并且返回后原页有数据可能需要更新， **必不可免的页面重新加载（虽然有 `keep-alive`），从而带来非常差的用户体验。**

在涉及到用户流畅使用体验的时候还是需要去权衡一下的，在如此情况下公司项目中能使用了第一种方法带来了 **近乎原生微信图片放大缩小的体验。**

## 三、具体解决

前面分析了问题的原因，现在来想一下如何才能具体实现在点击浏览器返回按钮时做到视觉上、体验上保留在当前页而不是返回上一页

点击浏览器返回，回到上一个浏览历史是无法阻止的，但是通过 `popstate` 事件可以监听浏览器历史变动，比如说：点击返回按钮、点击前进按钮

既然无法阻止浏览历史的返回那就来试试曲线救国，先来定义一下我们的逻辑：

1.  **A** 页面 --> 列表页
2.  **B** 页面 --> 详情页
3.  **C** 图片放大浮层 --> B页面点击图片放大出现

我们想要的逻辑是：         
> **A --> B [ 出现 C 浮层时点击返回 ] -->B**

如果想实现这种逻辑我们的实际的逻辑： 
> **A --> B --> B[ 重复的B页面 url,。出现 C 浮层后点击浏览器返回或者关闭按钮 ] -->B**

OK现在来代码实现，因为项目中有多处使用，直接抽调成vue的组件
```javascript
// 调用页
<template>
    <img src='xxxx.jpg' **v-on:click='enlargeImg($event)'**>
</template>
<script>
    methods:{
        enlargeImg(){
            this.$refs.imgOrigin.init([e.target]);
        }
    }
</script>
```

```javascript
// 放大图片组件
<template>
    xxxx...
</template>
<script>
    data(){
        return{
            imgObj: {}
        }
    },
    methods:{

        hackBack(){

            /*  点击浏览器返回按钮之后销毁当前页绑定浏览器按钮事件
                在当前浏览器历史栈添再次加一个当前URL
                触发 photoswipe close 方法，同时触发 close listen 的函数
                ---------------------------------------------------------*/ 
            window.removeEventListener('popstate',this.hackBack,false);

            history.pushState('back','',window.location.href);

            this.imgObj.close();
        }, 
        init(img){

            /*  绑定浏览器返回按钮事件
                浏览器历史栈添加一个当前URL来hack vue-router 防止URL变动触发 vue 渲染
                ----------------------------------------------------------------------*/ 
            history.pushState('back','',window.location.href);

            window.addEventListener('popstate', this.hackBack,false);

            this.imgObj = new PhotoSwipe(xxxxx....);

                /*  监听 photoswipe close 方法，
                    在点击右上角关闭按钮时触发，浏览器返回上一历史
                    销毁当前页绑定浏览器按钮事件
                    ---------------------------------------------*/ 
            this.imgObj.listen('close',()=>{
                window.removeEventListener('popstate',this.hackBack,false);
                history.back();
            })
        }
    }
</script>
```

代码只有片段可能显得不太清楚，不过总体的逻辑都在里面了，下面来总结一下总体流程：

1. 进入A页面

2. 进由A页面进入B页面

3. 在B页面点击某一张图片

4. 打开放大图片的浮层、添加一条与当前页面相同的历史纪录、监听浏览器历史事件、监听 `photoswipe close API` 即 `listen` 事件

5. 关闭浮层，这里关闭浮层分为俩种情况

1.  第一种，点击 `photoswipe` 自带的右上角关闭按钮，通过监听 `close` 的 `listen` 事件来捕获触发，当捕获到点击了关闭按钮之后：关闭浮层、返回上一个浏览器历史、消毁浏览器监听的 `photoswipe` 事件
2.  第二种，点击浏览器的返回按钮。这时通过监听 `popstate` 方法监听浏览器历史返回事件捕获事件发生。点击浏览器返回按钮后：关闭浮层、返回上一个浏览器历史、消毁当前页面绑定的 `popstate` 事件。由于关闭浮层时会触发 `close` 的 `listen` 事件，而 `listen` 事件又会返回上一个浏览器历史所以在调用 `close` 之前再对浏览器历史中再次添加一个相同的历史纪录，这样抵消了 `listen` 事件中的浏览器返回。

3. 继续留在B页面

通过文字叙述+代码已经说明白这个 hack 浏览器返回的方法，下面GIF说明修改之后:

![](https://www.ismoon.cn/static/bd3de639a25dcbe0c06b02763f04c5e9.gif)

可以看到已经达到了预期效果。

其实这里还有一个问题：因为添加了重复的浏览器历史，用户依旧可以点击浏览器前进按钮、IOS微信中前进按钮。当然用户点击之后页面不会变化因为url是一样的，页面逻辑就是 **A-->b-->b** ，这时在后面的b页面，需要点击俩次返回按钮才能回到A。那么这个问题怎么解决呢？

下面来说。

## 四、收尾，其他问题修复

上面说了一个意料之外的问题，不过问题明显解决的办法依旧很明显。上面在添加的重复历史记录标记了特殊字符串“back”，前面说了点击浏览器返回是不可阻挡的，那么在点击跳转之后通过判断 `event.state` 得到当前页面是否是添加的重复页，从而进行手动浏览器历史回退，代码如下：
```javascript
history.pushState('back','',window.location.href);

/* 图片返回全局浏览器按钮监听
---------------------------*/
window.addEventListener('popstate',function(event){

    if(event.state == 'back'){ history.back();}
},false);
```
至此对于一个图片放大的需求完善了。但是在单页面开发中还有很多时候需要浏览器返回 hack 操作，有的能解决，有的目前尚无好的解决办法，以后再遇此类问题，再次记录。