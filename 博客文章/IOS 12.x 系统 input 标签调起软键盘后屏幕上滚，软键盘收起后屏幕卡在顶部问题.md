
最近开发中 IOS 12+ 手机出现了比较多的兼容问题一个是用户收到验证码短信后弹起键盘点击“来自短信：123456”会在输入框中出现 “123456123456”，重复了俩次验证码。

解决的办法也很简单：`input` 通过 `maxlength` 属性控制位数即可。

另外一个问题就比较麻烦了，IOS 12+ 手机微信中公众号页面中 `input` 聚焦软键盘弹起从而带动页面上滚（IOS以往版本显示效果相同，但是没有这次的系统BUG），当用户输入完毕点击完成等按钮后 `input` 失焦，然后BUG就出现了：**因为软键盘弹起而往上滚动的页面没有像以往IOS 版本中随着软键盘滚动下来！！！**

恶心的事由此而来，系统没有自动滚动下来需要手动滚动一下才能恢复原样，这次就是记录这个恶心的 IOS 系统 BUG 以及解决的方法。

## 一、问题展示

没JB说个图：

![](https://www.ismoon.cn/static/561aaf8e2e9ea306e1bdcb6ac4c1c525.gif)

可以从图中看到，每次软键盘弹起再收回后被弹起的部分并没有往下滚动。

这里BUG出现的动图中可以观察到顶部 `fixed` 的 DOM 部分（”中药饮片“那一栏）并没有问题，由此可以判断此BUG一个出现的前提那就是需要有 **body 滚动元素**

这里 `body` 滚动元素指了俩部分：
> 其一， `input` 标签聚焦后页面会被弹起往上滚动，而这个滚动不是说所有页面都会的，如果这个 `input` 在顶部或者一个比较靠上的位置那么软键盘就不会把页面往上顶，从而就没有这个问题> 其二，这个 `input` 的外层DOM的CSS中是不含有 **fixed、absolute** 定位属性

在实际问题探索中总结到这俩个问题出现的前提，总的一看感觉有点苛刻，其实不然，绝大多数布局中这种BUG 出现的几率很大。

在搜了京东公众号等几个公众号操作了一下均出现了这个 BUG，不过他们的 `input` 都在顶部位置影响微乎其微。

**不过有问题就要解决虽然这是一个IOS 12+ 本身的问题。**

> 这里还有一个问题：页面卡在顶部后手动划一点点距离页面马上恢复、卡在顶部的标签点击一些按钮也无法触发。页面给人一种渲染错误的感觉，既然想到了渲染错误那就利用**浏览器的重绘**来试试到底是不是这个原因，想到既做到：键盘失焦后给`body {width: -1px}` 这种宽度修改 100% 会触发浏览器重绘，但是在测试之后可以肉眼观测到边框缩小了一点点，但是页面依旧卡在顶部没有恢复。

## 二、解决方案

废话不多说，问题本身很明显了，解决办法依旧明显：**既然你不听话不滚动下来，那么我给你 `scrollTop = 0` 设置一个值强制你滚动一下**

在测试这种办法后问题解决，但是这样解决必然引来一个问题：**每次点击 `input` 都会让页面滚动到顶部**

有问题那就再解决：**`input` 失焦后 `scrollTop = scrollTop;` 让 `input` 滚动到原先的位置**

看似完美的解决了问题，但是细想一下并不是每个页面当 `input` 失焦之后都要退回到页面原先位置的，并且一个项目中不能每个 `input` 都在当前页面中绑定失焦事件然后去滚动页面，维护性很差。

在思索之后有了一个非常OK的方式：**增加页面 height 从而使页面自行滚动一下，避免直接控制 scrollTop 属性**

## 三、具体解决

在思考之后方法已经有了就差实现，code 如下：
```javascript
/* bug_ios_input 为需要添加监听的 input 元素
--------------------------------------------*/
$('body').on('blur','.bug_ios_input',function(){

    let scrollEl = 'body';

    let scrollHei = ($(scrollEl).height() >= $(window).height() ? $(scrollEl).height(): $(window).height()) +1;

    $(scrollEl).css('height', scrollHei + 'px');

    setTimeout(e=>{ $(scrollEl).css('height', 'auto') }, 200);
});
```
在 `APP.vue` 中绑定全局 `input blur` 事件通过 `$('body').height() +1` 操作增加当前页面高度。

但是，页面不能每次点击 `input` 之后都要 `height +1`，一直 `+1` 会导致页面高度显著增加，但是经过测试 `height -1` 操作无效。那么怎么办呢？

![](https://www.ismoon.cn/static/b1090214b3c604fa843b54955e86e675.gif)

答案就是每次 `height +1` 之后通过

`setTimeout(e=>{ $('body').css('height', 'auto') }, 200);`来让页面恢复它本身被撑起来的高度。在恢复原本 `height` 之后再次 `height+1` 这样就不会让页面无限制的增加高度了。

并且这样做也在无意中解决了一个其他的副作用，这个副作用就是 `body` 的 `height` 写死后其他页面也都会被共享，这是绝对不想看到的。在通过异步延时之后将 `height` 属性设置为默认值从而解决了无限 `+1` 问题，也解决了 `height` 写死为定值问题。

解决之后上图:

![](https://www.ismoon.cn/static/d2fd0cfebaa1d94fed70f7a0575315fa.gif)

动图中完美解决。至于那高度动了那么一点点很细微，完全不会影响用户体验、操作。

## 四、收尾、其他问题修复

到这里这个问题基本上已经完美解决了，只差了一点还没有写下来，那就是这个 `height +1` 是有前提的，这个前提就是 **页面高度需要 >= `window.height`** 才能强迫页面滚动一下。

这也就是前面代码中 `let scrollHei = ($(scrollEl).height() >= $(window).height() ? $(scrollEl).height(): $(window).height()) +1;` 的作用。

至此这次解决问题过程中所有问题都解决了。IOS 12+ 问题确实多多，这中基本功能问题都会出问题，而且目前最新版依旧没有修复。

后续再有 IOS 12+系统BUG导致的问题再来记录。