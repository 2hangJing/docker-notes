<!--
 * @Author: monai
 * @Date: 2021-08-30 11:25:48
 * @LastEditors: monai
 * @LastEditTime: 2021-08-30 18:34:23
-->
# 二叉树遍历

给定一个二叉树，返回它的 前序、中序、后序、层次遍历。
```javascript
//  二叉树顺序存储数据
let list = [1, null, 2, 3];
//  二叉树 JS 对象模拟数据
let tree = {
    val: 1,
    left: null,
    right: {
        val: 2,
        left: {
            val: 3,
            left: null,
            right: null
        },
        right: null
    }
};
//  树结构
//    1
//     \
//      2
//     /
//    3 
```

## 1. 前序遍历
**前序遍历：父节点->左子树->右子树**

* **递归**  
```javascript
let preorderTraversal_recursion = (tree)=>{
    let list = [];
    let recursionFunc = (node)=>{
        if(node === null)return;
        // 注入数据
        list.push(node.val);
        recursionFunc(node.left);
        recursionFunc(node.right);
    }
    recursionFunc(tree)
    return list;
}
preorderTraversal_recursion(tree); // [1,2,3]
```

* **迭代**
```javascript
//  迭代
let preorderTraversal_iteration = (tree)=>{
    let list = [];
    // 根元素入栈
    let stack = [tree];
    
    while(stack.length>0){
        // 栈顶元素出栈
        let node = stack.pop();
        if(node === null)continue;
        // 二叉树顺序存储值
        list.push(node.val)
        // 因为前序遍历顺序为：父-> 左-> 右，所以先把右子树入栈
        stack.push(node.right);
        // 再入栈左子树，下次循环时直接从栈顶取出左子树数据
        stack.push(node.left);
    }  
    return list;
}
preorderTraversal_iteration(tree); // [1,2,3]
```
**参考：https://github.com/sisterAn/JavaScript-Algorithms/issues/37**

## 2. 中序遍历
**左子树->父节点->右子树**
* **递归**  
```javascript
let preorderTraversal_recursion = (tree)=>{
    let list = [];
    let recursionFunc = (node)=>{
        if(node === null)return;
        // 注入数据
        list.push(node.val);
        recursionFunc(node.left);
        recursionFunc(node.right);
    }
    recursionFunc(tree)
    return list;
}
preorderTraversal_recursion(tree); // [1,2,3]
```

* **迭代**
```javascript
//  迭代
let preorderTraversal_iteration = (tree)=>{
    let list = [];
    // 根元素入栈
    let stack = [tree];
    
    while(stack.length>0){
        // 栈顶元素出栈
        let node = stack.pop();
        if(node === null)continue;
        // 二叉树顺序存储值
        list.push(node.val)
        // 因为前序遍历顺序为：父-> 左-> 右，所以先把右子树入栈
        stack.push(node.right);
        // 再入栈左子树，下次循环时直接从栈顶取出左子树数据
        stack.push(node.left);
    }  
    return list;
}
preorderTraversal_iteration(tree); // [1,2,3]
```


