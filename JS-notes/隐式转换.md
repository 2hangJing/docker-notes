
# JS 类型转换

## 强制类型转换


## 隐式类型转换
隐式转换主要体现在各种操作符计算中，大体规则如下：

#### 前置知识
**1. `Number` 强制转换**：

顾名思义，其他类型转换为 `Number` 类型，规则较多，参考 MDN：<https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number#number_%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2>

#### 加法运算符 +

加法操作符是非常特殊的一类，不仅规则众多就连操作符本身也区分一元、二元两种情况处理。

##### Ⅰ. 作为一元操作符

`+` 作为一元操作符时与 `Number()` 函数进行类型转换规则相似，只有 `BigInt` 转换有区别，其他完全相同。

转换的规则为：**前置知识：1. `Number` 强制转换**。

##### Ⅱ. 作为二元操作符

作为二元操作符时，有两条转换规则，**规则 A 优先级大于 B。**

**A.** 一侧数据类型为 `String` 则另外一侧也转换为 `String`，然后进行字符串拼接。各种不同情况如下示例：
```javascript
'0' + 0         // '00'
'0' + 0         // '00'
'0' + {}        // '0[object Object]'
'0' + null      // '0null'
'0' + undefined // '0undefined'
'0' + Infinity  // '0Infinity'
```

**B.** 一侧数据类型为 `Number` 则另外一侧也将类型转换为 `Number` 进行算数运算，各种不同情况如下示例：

- 对象：先后调用 `valueOf()`、`toString()` 获取原始值，进行运算。
    ```javascript
    0 + {}      // '0[object Object]'
    // 实际运算逻辑如下：
    0 + {}.valueOf();
    // 👇
    0 + {};
    // 👇
    0 + {}.toString();
    // 👇 （此时运算规则符合 A，进行字符串拼接）
    0 + '[object Object]'; 
    // 👇
    '0[object Object]'
    ```

    **注意：不同对象调用这两个函数时返回值可能不同。**
    例如：`Array` 调用 `toString()` 实际上是 `join()`。
    ```javascript
    0 + []          // '0'
    0 + [1,2,3]     // '01,2,3'
    ```
    例如：`Function` 调用 `toString()` 返回是函数本体字符串。
    ```javascript
    0 + (() => {})    // '0() => {}'
    ```

- 其他所有类型执行 `Number` 强制转换后再进行算数运算，各种不同情况如下示例：
    ```javascript
    0 + true        // 1 ps: true=>1 false=>0
    0 + null        // 0
    0 + undefined   // NaN ps: undefined=>NaN
    0 + 'B'         // '0B' 符合规则 A，此处执行字符串拼接
    0 + ''          // 0
    0 + ' '         // 0 ps: 空字符串与仅为空格字符串都转化为 0
    //... 其他情况参考 `Number` 强制转换 后的值
    ```

#### 其他算数运算符 - * / %

两侧均 `Number` 强制转换，在进行算术运算。
```javascript
8 * true        // 8
0 * (()=>{})    // NaN
{} * {}         // NaN
// ...
```

#### 比较运算符


    






